* https://instant.1point3acres.com/thread/199501

### 第一轮


Coding: infinite matrix, 

```
有一个destination， 有一个source, 和一个blocks存一些不能走到坐标，问从source能不能到达destination， 
从source (x,y) 只能走:(x+/-1,y+/-2), (x+/-2, y+/-1) 8种组合。
注意Matrix是infinite的.
Follow up: optimization 
```

##### 思路

和国际象棋的Knight的move模式一样. 在没有blocks的情况下，knight是可以达到每个点的。
任何没有被blocks围起来的点都是可到达的。

由于matrix无限，不能没完没了的bfs 或是dfs。其实这次就是问，blocks里面的点可不可以把source或事destination围起来，围起来一个，就return false，othersize return true。我讲到这里，不知道有没有同学恍然大悟。是的，如果从source出发，或事destination出发，有一个无路可走就是false。那么问题来了，怎么判断无路可走，又是从哪个点走呢。答案是，必须从两点一起走，不然不行。： 1. 建立两个queue 分别存 source 和dest 接下来可以走的点。 2. 需要用两个visited_set记录source 和dest走过的点。 3. 用一个while loop 判断 source 和dest下一个可走的点。 4. 如果 下一个走的点在visited里面，或是blocks里面，不操作。否则把新的点加到queue里面。 5. 如果dest走到了source，或事source走到了dest，return true。 6. 如果两个queue又一个空了，说明这个点被blocks围住了，return false。 


### 第二轮

BQ+Coding: Matrix中有0和1， 求1组成的最大的plus （+）形状的长度.。

例如，下面的。 以（2,2）为中心的plus长度为1. （Plus的外围是一个正方形） 

```
0 0 1 0 0 1 0 
1 0 1 0 1 0 1 
1 1 1 1 1 1 1 
0 0 1 0 0 0 0 
0 0 0 0 0 0 0
```

##### 思路 

基本想法是扫四遍matrix, 第一次对matrix数每一行从左边开始有多少个1，第二次从右边数，第三次从上往下数每一列，第四次从下往上.
做四遍遍历，记录四个方向上每个格最长的连续长度，最后遍历一遍，取四个方向上的连续长度的最小值就是十字的大小了

时间和空间复杂度都是 O(MN)


第三轮：Design,设计FB event reminder， 就是允许用户设置在事件发生之前多长时间发出提醒， 主要是讲怎么扩展数据库 




第四轮：Coding, 给一个dictionary和一个字符串，可能有匹配符，如何建立一个data structure, 实现insert 和 search. 用Trie 和DFS

* https://leetcode.com/problems/add-and-search-word-data-structure-design/description/

