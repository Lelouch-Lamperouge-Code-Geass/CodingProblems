


// Write a program to find the n-th ugly number.
// Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
// For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
// Note that 1 is typically treated as an ugly number, and n does not exceed 1690.

class Solution {
public:
  int nthUglyNumber(int n) {
    // Here we set ugly_numbers[0] = 1 though we won't use it.
    // We just want to make sure the array is not 0-based.
    std::vector<int> ugly_numbers(n+1,1);

    // These three represents the index in ugly_numbers.
    // The keypoint here is that the next minimal ugly number is
    // always generated by previous ugly numbers multiply by 2,3, or 5.
    // Therefore, two, three, five points to the smallest ugly number which
    // satisifies , e.g. two * ugly_number[two + 1] > ugly_numbers.back()
    int two(0),three(0),five(0);

    for (int i = 2; i <= n; ++i) {
      int next_val = std::min(2 * ugly_numbers[two + 1], 3 * ugly_numbers[three + 1]);
      next_val = std::min(next_val, 5 * ugly_numbers[five + 1]);
      ugly_numbers[i] = next_val;

      if (next_val == 2 * ugly_numbers[two + 1]) ++ two;
      if (next_val == 3 * ugly_numbers[three + 1]) ++ three;
      if (next_val == 5 * ugly_numbers[five + 1]) ++ five;
    }

    return ugly_numbers[n];
  }
};
